package analizadores;

import java_cup.runtime.Symbol;
import java.util.LinkedList;
import errores.ErrorSintactico;
import instrucciones.*;
import enums.*;

parser code {:
    public LinkedList<Instruccion> AST;
    public LinkedList<ErrorSintactico> errores = new LinkedList<>();
    public void error_sintactico(Symbol s) {
        if (s.value != null)
            errores.add(new ErrorSintactico(s.value.toString(), s.left, s.right));
    }
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception {
                throw new Exception("Error irrecuperable en (linea, columna): " + s.left + ", " + s.right);
    }
:}

terminal String VOID, MAIN;
terminal String MAYOR, MENOR, MAYOR_IGUAL, MENOR_IGUAL, IGUAL, NO_IGUAL, NOT, OR, AND, PUNTO, INCREMENTO;
terminal String PUNTO_COMA, DOS_PUNTOS;
terminal String SUMA, RESTA, MULTIPLICACION, DIVISION;
terminal String PARENTESIS_IZQ, PARENTESIS_DER, LLAVE_IZQ, LLAVE_DER;
terminal String IF, ELSE, SWITCH, CASE, DEFAULT, SWITCH_BREAK, FOR, WHILE, DO, CONSOLE, WRITE;
terminal String NUM, STR, CHAR, TYPEDEF, ID, BOOLEAN;

non terminal ini;

non terminal LinkedList<Instruccion> statements;
non terminal Instruccion statement;
non terminal Operacion expr;
non terminal LinkedList<Elif> elifs;
non terminal LinkedList<Case> cases;
non terminal Case case;

non terminal Operacion aritmetic;
non terminal Operacion logical;
non terminal Operacion symbols;
non terminal Operacion unitary;

non terminal If if;

non terminal Instruccion function;

non terminal Instruccion mainstatement;
non terminal LinkedList<Instruccion> mainstatements;

precedence left MAYOR, MENOR, MAYOR_IGUAL, MENOR_IGUAL, IGUAL, NO_IGUAL;
precedence left AND, OR;
precedence left SUMA, RESTA;
precedence left MULTIPLICACION, DIVISION;
precedence left PARENTESIS_IZQ;

start with ini;

ini::= VOID MAIN PARENTESIS_IZQ PARENTESIS_DER LLAVE_IZQ  mainstatements:s LLAVE_DER {:parser.AST=s;:}
;

mainstatements ::= mainstatements:s mainstatement:t {:RESULT=s; RESULT.add(t);:}
| mainstatement:s {:RESULT = new LinkedList<Instruccion>(); RESULT.add(s);:}
;


mainstatement ::= statement:s {:RESULT = s;:}
| function:d {:RESULT = d;:};

statements ::= statements:s statement:t {:RESULT=s; RESULT.add(t);:}
| statement:s {:RESULT = new LinkedList<Instruccion>(); RESULT.add(s);:};
// Agregar produccion para variables ya declaradas
statement ::= TYPEDEF:n ID:t IGUAL expr:e PUNTO_COMA {:RESULT = new Asignacion(t,n,e);:}
| TYPEDEF:n ID:e PUNTO_COMA {:RESULT = new Declaracion(e,n);:}
| ID:i IGUAL expr:e PUNTO_COMA {:RESULT = new ReAsignacion(i,e);:}
| if:i {:RESULT=i;:}
| FOR PARENTESIS_IZQ TYPEDEF ID:i IGUAL expr:e PUNTO_COMA expr:f PUNTO_COMA ID INCREMENTO PARENTESIS_DER LLAVE_IZQ statements:s LLAVE_DER {:RESULT = new For(i,e,f,s);:}
| WHILE PARENTESIS_IZQ expr:e PARENTESIS_DER LLAVE_IZQ statements:s LLAVE_DER {:RESULT = new While(e,s);:}
| DO LLAVE_IZQ statements:e LLAVE_DER WHILE PARENTESIS_IZQ expr:s PARENTESIS_DER PUNTO_COMA {:RESULT = new DoWhile(e,s);:}
| CONSOLE PUNTO WRITE PARENTESIS_IZQ STR:s PARENTESIS_DER PUNTO_COMA {:RESULT = new Imprimir(s);:}
| CONSOLE PUNTO WRITE PARENTESIS_IZQ STR:s SUMA ID:e PARENTESIS_DER PUNTO_COMA {:RESULT = new Imprimir(s,e);:}
| SWITCH PARENTESIS_IZQ expr:e PARENTESIS_DER LLAVE_IZQ cases:c LLAVE_DER {:RESULT = new Switch(e,c);:}
| SWITCH PARENTESIS_IZQ expr:e PARENTESIS_DER LLAVE_IZQ cases:c DEFAULT DOS_PUNTOS statements:s LLAVE_DER {:RESULT = new Switch(e,c,s);:}
| error PUNTO_COMA
| error LLAVE_DER
;

impresiones ::= impresiones:s impresion:t
| impresion:s
;

impresion ::= impresion expr MAS
| impresion STR MAS
| expr
| STR

function ::=  VOID ID:f PARENTESIS_IZQ PARENTESIS_IZQ LLAVE_IZQ statements:s LLAVE_DER {:RESULT = new Funcion(f,s);:}
;

if ::= IF PARENTESIS_IZQ expr:e PARENTESIS_DER LLAVE_IZQ statements:s LLAVE_DER {:RESULT = new If(e,s);:}
| IF PARENTESIS_IZQ expr:e PARENTESIS_DER LLAVE_IZQ statements:p LLAVE_DER ELSE LLAVE_IZQ statements:s LLAVE_DER {:RESULT = new If(e,p,s);:}
| IF PARENTESIS_IZQ expr:e PARENTESIS_DER LLAVE_IZQ statements:s LLAVE_DER elifs:f {:RESULT = new If(e,s,f, null);:}
| IF PARENTESIS_IZQ expr:e PARENTESIS_DER LLAVE_IZQ statements:s LLAVE_DER elifs:f ELSE LLAVE_IZQ statements:p LLAVE_DER {:RESULT = new If(e,s,f,p);:}
;

elifs ::= elifs:f ELSE IF PARENTESIS_IZQ expr:e PARENTESIS_DER LLAVE_IZQ statements:s LLAVE_DER {:RESULT = f; RESULT.add(new Elif(e, s));:}
| ELSE IF PARENTESIS_IZQ expr:e PARENTESIS_DER LLAVE_IZQ statements:s LLAVE_DER {:RESULT = new LinkedList<Elif>(); RESULT.add(new Elif(e, s));:}
;
cases ::= cases:s  case:t {:RESULT=s; RESULT.add(t);:}
| case:s {:RESULT = new LinkedList<Case>(); RESULT.add(s);:}
;

case ::= CASE expr:e DOS_PUNTOS statements:s {:RESULT = new Case(e,s, false);:}
|CASE expr:e DOS_PUNTOS statements:s SWITCH_BREAK {:RESULT = new Case(e,s, true);:}
;

expr ::= symbols:s {:RESULT = s;:}
| unitary:u {:RESULT = u;:}
| aritmetic:a {:RESULT = a;:}
| logical:l {:RESULT = l;:}
| PARENTESIS_IZQ expr:e PARENTESIS_DER {:RESULT = new Operacion(e);:};

aritmetic ::= expr:a SUMA expr:b {:RESULT = new Operacion(a, EnumOperaciones.SUMA, b);:}
| expr:a RESTA expr:b {:RESULT = new Operacion(a, EnumOperaciones.RESTA, b);:}
| expr:a MULTIPLICACION expr:b {:RESULT = new Operacion(a, EnumOperaciones.MULTIPLICACION, b);:}
| expr:a DIVISION expr:b {:RESULT = new Operacion(a, EnumOperaciones.DIVISION, b);:}
| NUM:n  {: RESULT = new Operacion(n, EnumTerminals.NUM); :};

logical ::= expr:a MAYOR expr:b {:RESULT = new Operacion(a, EnumOperaciones.MAYOR, b);:}
| expr:a MENOR expr:b {:RESULT = new Operacion(a, EnumOperaciones.MENOR, b);:}
| expr:a MAYOR_IGUAL expr:b {:RESULT = new Operacion(a, EnumOperaciones.MAYOR_IGUAL, b);:}
| expr:a MENOR_IGUAL expr:b {:RESULT = new Operacion(a, EnumOperaciones.MENOR_IGUAL, b);:}
| expr:a IGUAL expr:b {:RESULT = new Operacion(a, EnumOperaciones.IGUAL, b);:}
| expr:a NO_IGUAL expr:b {:RESULT = new Operacion(a, EnumOperaciones.NO_IGUAL, b);:}
| expr:a AND expr:b {:RESULT = new Operacion(a, EnumOperaciones.AND, b);:}
| expr:a OR expr:b {:RESULT = new Operacion(a, EnumOperaciones.OR, b);:}
| BOOLEAN:b {:RESULT = new Operacion(b, EnumTerminals.BOOLEAN);:}
;

symbols ::= ID:i {:RESULT = new Operacion(i, EnumTerminals.ID);:}
| STR:s {:RESULT = new Operacion(s, EnumTerminals.STR);:}
| CHAR:c {:RESULT = new Operacion(c, EnumTerminals.CHAR);:} ;

unitary ::= RESTA expr:e {:RESULT = new Operacion(e, EnumUnitaryOperations.NEGATIVE);:}
| NOT expr:e {:RESULT = new Operacion(e, EnumUnitaryOperations.NOT);:};

